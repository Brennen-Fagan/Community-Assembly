---
title: "Using ReacTran to setup a heat-like equation, 2"
output:
  html_notebook:
    code_folding: hide
---

```{r}
set.seed(75771606)
packages <- c(
  "dplyr",
  "deSolve",
  "rootSolve",
  "RMTRCode2",
  "ReacTran"
)
for (pkg in packages) {
  library(pkg, character.only = TRUE)
}
```

# Heat on a Circle

$$
\begin{aligned}
\partial_t u &= \Delta u \\
u(x, 0) &= f(x) \\
u(0, t) &= u(L, t)
\end{aligned}
$$

```{r}
cells <- 100
simlenth <- 1
# N = Num. of Grid Cells, L = Length
Grid <- ReacTran::setup.grid.1D(N = cells, L = simlenth)
```

If there are grid properties, we can set them up as a layer/variable as follows.

```{r}
propR <- ReacTran::setup.prop.1D(grid = Grid, func = function(r) r)
```

Define the pde function.
Note that zero gradient is the default $\partial_x u = 0$.
To change it we use the `C.up` and `C.down` arguments.

```{r}
functionHeat <- function(time, Concentration, parameters, 
                         Area = 1, Diffusion = 1, GridThickness = Grid,
                         Circular = TRUE) {
  
  if (Circular) {
    # Need to adjust anything that is changed by adding grid cells.
    Concentration <- c(Concentration[length(Concentration)],
                                   Concentration,
                                   Concentration[1])
    
    if ("dx" %in% names(GridThickness)) {
      GridThickness <- GridThickness$dx
    }
    GridThickness <- c(GridThickness[length(GridThickness)],
                                   GridThickness,
                                   GridThickness[1])
  }
  
  
  tran <- ReacTran::tran.1D(
    C = Concentration, A = Area, D = Diffusion,
    #C.up = 0, C.down = 0, 
    # Options for boundary conditions:
    # No flow
    # Constant Concentration: Doesn't seem right. This conflicts with the
    # copying of the boundaries. In theory, we'd want these to be the
    # actual values at the other end.
    # Constant Flow: Again, doesn't seem right, for same reasons as above.
    # Advective: seems similar to the Constant concentration case...
    dx = GridThickness
  )$dC
  
  if (Circular) tran <- tran[c(-1, -length(tran))] 
  list(tran)
}
```

Steady state solution from `rootSolve`.
```{r}
ylocs <- (1:cells) / cells * simlenth
initCondition <- cospi(ylocs) + 1
steadyHeat <- rootSolve::steady.1D(
  y = dnorm(ylocs, mean = 0.1, sd = 0.05) , #initCondition,
  func = functionHeat,
  parms = NULL, nspec = 1 #nspec = Number of species
  )
plot(ylocs, steadyHeat$y)
```

Now look at the DE forward solved equivalents.

First, the keep each end fixed at value 0.

```{r}
ts <- (1:cells) / cells * 20
deHeat <- deSolve::ode.1D(
  y = dnorm(ylocs, mean = 0.1, sd = 0.05) ,#initCondition, 
  times = ts,
  func = functionHeat,
  parms = NULL,
  nspec = 1,
  D = 0.01
)
image(deHeat, grid = Grid$x.mid, xlab = "time", ylab = "distance", add.contour = TRUE)
```

So it seems (again!) that there is something about the way I am using the 
`rootSolve` package that does not seem to match up with expectations.
On the other hand, the `deSolve` package does seem to match better. 

# Interacting Population Diffusions

Now we want to consider the case of multiple species living together.
We quickly assemble a system to test on.

```{r}
exampleAssembly <- RMTRCode2::LawMorton1996_NumericalAssembly(
  Basal = 50, Consumer = 50, ArrivalEvents = 2500
)
temp <- RMTRCode2::LawMorton1996_PlotAbundance(exampleAssembly$Abundance, guides = FALSE)
temp
```

Check to make sure we have an uninvadable community.
```{r}
nrow(exampleAssembly$Sequence) > which.max(is.na(exampleAssembly$Sequence$Outcome[-1]))
```

Grab the community and its reduced matrix and pool.
```{r}
redComNum <- which.max(is.na(exampleAssembly$Sequence$Outcome[-1])) - 1
redCom <- exampleAssembly$Sequence$Community[[redComNum]]
redPool <- exampleAssembly$Pool[redCom, ]
redMat <- exampleAssembly$Matrix[redCom, redCom]
```

Create the function.
```{r}
functionCommunity <- function(time, Concentration, parameters, 
                         Area = 1, Diffusion = 1, GridThickness = Grid,
                         Pool = redPool, Mat = redMat, Verbose = FALSE,
                         ExtinctionThreshold = 0, Circular = FALSE) {
  if(Verbose) print(Concentration)
  
  Concentration[Concentration < ExtinctionThreshold] <- 0
  
  # Looking at deSolve documentation, it looks like we should break up
  # Concentration, e.g.:
  # PREY <- state[1:N]
  # PRED <- state[(N+1):(2*N)]
  # So in general, columns are per species pipes,
  # while the rows are the same point on a pipe but for each species.
  pipeMatrix <- matrix(data = Concentration, ncol = nrow(Pool))
  # Note that matrix automatically fills downward!
  
  # Idea with circular: attach duplicates of first, last evaluation points.
  # Then evaluate as normal. Before finishing, remove the duplicate entries.
  # Order of additions matters.
  if (Circular > 0) {
    pipeMatrix <- rbind(pipeMatrix[-Circular:-1 + 1 +nrow(pipeMatrix), ],
                                   pipeMatrix,
                                   pipeMatrix[1:Circular, ])
    
    if ("dx" %in% names(GridThickness)) {
      GridThickness <- GridThickness$dx
    }
    GridThickness <- c(GridThickness[-Circular:-1 + 1 + length(GridThickness)],
                                   GridThickness,
                                   GridThickness[1:Circular])
  }
  
  if(Verbose) print(pipeMatrix)
  
  pipeMatrixTran <- apply(pipeMatrix, MARGIN = 2, FUN = function(C, A, D, G) {
    ReacTran::tran.1D(
      C = C, A = A, D = D, dx = G
    )$dC
  }, A = Area, D = Diffusion, G = GridThickness)
  
  if(Verbose) print(pipeMatrixTran)
  
  pipeMatrixComm <- t(apply(pipeMatrix, MARGIN = 1, FUN = function(C, t, P, M) {
    unlist(GeneralisedLotkaVolterra(t = t, y = C, 
                             parms = list(
                               a = M,
                               r = P$ReproductionRate
                             )))
  }, t = time, P = Pool, M = Mat))
  
  if(Verbose) print(pipeMatrixComm)
  
  # Order of deletions does not matter.
  if(Circular) pipeMatrixTran <- pipeMatrixTran[
    c(-1:-Circular, -1:-Circular + 1 + nrow(pipeMatrixTran)), ] 
  if(Circular) pipeMatrixComm <- pipeMatrixComm[
    c(-1:-Circular, -1:-Circular + 1 + nrow(pipeMatrixComm)), ] 
  
  list(pipeMatrixTran + pipeMatrixComm)
}
```

Now we try running it
```{r}
deAssembly <- deSolve::ode.1D(
  y = matrix(
    c(
      exampleAssembly$Abundance[nrow(exampleAssembly$Abundance), -1][redCom],
      rep(0, (cells - 1)* length(redCom))
    ),
    ncol = length(redCom), byrow = TRUE
    ), 
  times = seq(0, 300, by = 0.1),
  func = functionCommunity,
  parms = NULL,
  D = 0.001,
  nspec = length(redCom),
  Verbose = FALSE
)
```

```{r}
image(deAssembly, grid = Grid$x.mid, xlab = "time", ylab = "distance", add.contour = TRUE)
```

```{r}
deAssemblyCirc <- deSolve::ode.1D(
  y = rbind(
    matrix(0, nrow = (cells/2) - 1, ncol = length(redCom)),
    matrix(
      c(
        exampleAssembly$Abundance[nrow(exampleAssembly$Abundance), -1][redCom]
      ),
      ncol = length(redCom), byrow = TRUE
    ),
    matrix(0, nrow = (cells/2), ncol = length(redCom))
    ), 
  times = seq(0, 300, by = 0.1),
  func = functionCommunity,
  parms = NULL,
  D = 0.001,
  nspec = length(redCom),
  Verbose = FALSE,
  Circular = floor(cells/2)
)
```

```{r}
image(deAssemblyCirc, grid = Grid$x.mid, xlab = "time", ylab = "distance", add.contour = TRUE)
```
Results seem consistent regardless of starting position for a circular system.
Results seem inconsistent, however, with the non-circular system!
It might be an issue of timespan.
(We expect the "heat" to disperse evenly throughout the "pipe". 
We also expect the system to head back to its "native" steady-state.)

```{r}
deAssembly <- deSolve::ode.1D(
  y = matrix(
    c(
      exampleAssembly$Abundance[nrow(exampleAssembly$Abundance), -1][redCom],
      rep(0, (cells - 1)* length(redCom))
    ),
    ncol = length(redCom), byrow = TRUE
    ), 
  times = seq(0, 3000, by = 1),
  func = functionCommunity,
  parms = NULL,
  D = 0.001,
  nspec = length(redCom),
  Verbose = FALSE
)
```

```{r}
image(deAssembly, grid = Grid$x.mid, xlab = "time", ylab = "distance", add.contour = TRUE)
```

```{r}
deAssemblyCirc <- deSolve::ode.1D(
  y = rbind(
    matrix(0, nrow = (cells/2) - 1, ncol = length(redCom)),
    matrix(
      c(
        exampleAssembly$Abundance[nrow(exampleAssembly$Abundance), -1][redCom]
      ),
      ncol = length(redCom), byrow = TRUE
    ),
    matrix(0, nrow = (cells/2), ncol = length(redCom))
    ), 
  times = seq(0, 3000, by = 1),
  func = functionCommunity,
  parms = NULL,
  D = 0.001,
  nspec = length(redCom),
  Verbose = FALSE,
  Circular = floor(cells/10)
)
```

```{r}
image(deAssemblyCirc, grid = Grid$x.mid, xlab = "time", ylab = "distance", add.contour = TRUE)
```

Empirically speaking, the values do tend towards the steady state. 
The dynamics getting there, on the other hand, seem less uniform.
```{r}
image(deAssembly, grid = Grid$x.mid, xlab = "time", ylab = "distance", add.contour = TRUE,
      subset = time > 1 & time < 100)
image(deAssemblyCirc, grid = Grid$x.mid, xlab = "time", ylab = "distance", add.contour = TRUE,
      subset = time > 1 & time < 100)
```
