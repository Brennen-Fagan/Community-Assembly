---
title: "Law and Morton 1996: Numerical Scaling"
author: "Brennen Fagan"
date: "Created 2021-03-22, last compiled `r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(RMTRCode2)
library(foreach)
parallelise <- tryCatch(
  {
    library(parallel)
    library(doParallel)
    TRUE
  },
  error = function(e) {
    return(FALSE)
  }
)
if (parallelise) {
  cores <- max(c(parallel::detectCores() - 1, 1))
  clust <- parallel::makeCluster(cores)
  doParallel::registerDoParallel(clust)
} else {
  foreach::registerDoSEQ()
}
library(ggplot2)
library(dplyr)
library(tidyr)

export_calculation <- TRUE
vers <- 3# of 1, 2.
```

```{r parameters2}
if (vers == 1) {
  # > runif(1) * 1E8
  # [1] 38427042
  set.seed(38427042)
  
  basal <- c(3, 10, 30, 100, 300, 1000)
  consumer <- c(3, 10, 30, 100, 300, 1000) * 2
  events <- (max(basal) + max(consumer)) * 2
  runs <- 100
  
  logBodySize <- c(-2, -1, -1, 1) # Morton and Law 1997 version.
  parameters <- c(0.01, 10, 0.5, 0.2, 100, 0.1)
  
  seedsPrep <- runif(2 * length(basal) * length(consumer)) * 1E8
  seedsRun <- runif(runs * length(basal) * length(consumer)) * 1E8
} else {
  source(paste0(
    "LawMorton1996-NumericalPoolCommunityScaling-Settings", vers, ".R"
  ))
}
```

```{r pools2}
pools <- foreach::foreach(
  b = rep(basal, times = length(consumer)),
  c = rep(consumer, each = length(basal)),
  s = seedsPrep[1:(length(basal) * length(consumer))],
  .packages = c("RMTRCode2")
) %dopar% {
  LawMorton1996_species(
    Basal = b, 
    Consumer = c, 
    Parameters = parameters, 
    LogBodySize = logBodySize,
    seed = s
  )
}
```
```{r commats2}
communityMats <- foreach::foreach(
  s = seedsPrep[
    (length(basal) * length(consumer) + 1):(
      2 * length(basal) * length(consumer))
  ],
  Pool = pools,
  .packages = c("RMTRCode2"), .export = c(".Random.seed")
) %dopar% {
  if (exists("Competition"))
    LawMorton1996_CommunityMat(
      Pool = Pool, 
      Parameters = parameters,
      seed = s,
      Competition = Competition,
      Mutualism = Mutualism,
      CompetitionBasal = CompetitionBasal,
      Connectance = Connectance,
      DiagParam = DiagParam
    )
  else 
    LawMorton1996_CommunityMat(
      Pool = Pool, 
      Parameters = parameters,
      seed = s
    )
}

if (export_calculation) {
  filenameExported <- if (vers == 1) {
    "LawMorton1996-NumericalPoolCommunityScaling-PoolMats.RDS"
  } else {
    paste0("LawMorton1996-NumericalPoolCommunityScaling-PoolMats", vers, ".RDS")
  }
  save(
    file = filenameExported,
    communityMats,
    pools
  )
}
```

```{r table3runsv2} 
if (export_calculation) {
  load(
    file = "LawMorton1996-NumericalPoolCommunityScaling-results.RDS"
  )
} else {
  results <- foreach::foreach(
    i = 1 : (length(basal) * length(consumer)),
    ourPool = iterators::iter(pools),
    ourMat = iterators::iter(communityMats)
  ) %:% foreach::foreach(
    seed = iterators::iter(seedsRun[((i - 1) * runs + 1) : (i * runs)])
  ) %dopar% {
    # ourPool <- pools[[i]]
    # ourMat <- communityMats[[i]]
    
    aRun <- LawMorton1996_NumericalAssembly(
      Pool = ourPool, 
      CommunityMat = ourMat,
      IntegratorTimeStep = 10000,
      InnerTimeStepSize = 5000, 
      ArrivalEvents = events,
      ReturnValues = c("Abundance", "Sequence"), 
      seed = seed
    )
    
    lastRow <- which(is.na(aRun$Sequence$Community[-1]))[1]
    if (is.na(lastRow)) {
      lastRow <- nrow(aRun$Sequence)
    }
    aRun$Sequence <- aRun$Sequence[1:lastRow, ]
    
    if (LawMorton1996_CheckUninvadable(
      AbundanceRow = aRun$Abundance[nrow(aRun$Abundance), ],
      Pool = ourPool,
      CommunityMatrix = ourMat
    )) {
      # and, if so, store the result.
      return(aRun$Sequence)
    } else {
      return(toString(NULL))
    }
  }
}
```

```{r recreateTable7}
tableSetup <- lapply(
  seq_along(results), function(i, r, b, c) {
    do.call(
      rbind, 
      lapply(r[[i]], function(x) {
        if (!is.atomic(x)) {
          data.frame(
            Iterations = nrow(x), 
            Endpoint = toString(x$Community[[nrow(x)]]), 
            Type1 = sum(x$Outcome == "Type 1 (Failure)", na.rm = TRUE)
          )
        }
      })) %>% dplyr::group_by(Endpoint) %>% dplyr::summarise(
        MeanIterations = mean(Iterations, na.rm = TRUE),
        MedianIterations = median(Iterations, na.rm = TRUE),
        Successful = n()
      ) %>% dplyr::mutate(
        Basal = b[i],
        Consumers = c[i]
      )
  },
  r = results, 
  b = rep(basal, times = length(consumer)),  
  c = rep(consumer, each = length(basal))
)
```

```{r displayTable}
tableSetup
```

```{r finished}
if (parallelise) {
  parallel::stopCluster(clust)
}
```
