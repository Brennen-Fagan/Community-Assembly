---
title: "Using ReacTran to setup a heat-like equation"
output:
  html_notebook:
    code_folding: hide
---

```{r}
set.seed(84650581)
packages <- c(
  "dplyr",
  "deSolve",
  "rootSolve",
  "RMTRCode2",
  "ReacTran"
)
for (pkg in packages) {
  library(pkg, character.only = TRUE)
}
```

# Heat

$$
\begin{aligned}
\partial_t u &= \Delta u \\
u(x, 0) &= f(x) \\
u(0, t) = 0 &= u(L, t)
\end{aligned}
$$

```{r}
cells <- 100
simlenth <- 1
# N = Num. of Grid Cells, L = Length
Grid <- ReacTran::setup.grid.1D(N = cells, L = simlenth)
```

If there are grid properties, we can set them up as a layer/variable as follows.

```{r}
propR <- ReacTran::setup.prop.1D(grid = Grid, func = function(r) r)
```

Define the pde function.
Note that zero gradient is the default $\partial_x u = 0$.
To change it we use the `C.up` and `C.down` arguments.

```{r}
functionHeat <- function(time, Concentration, parameters, 
                         Area = 1, Diffusion = 1, GridThickness = Grid) {
  tran <- ReacTran::tran.1D(
    C = Concentration, A = Area, D = Diffusion,
    C.up = 0, C.down = 0, dx = GridThickness
  )$dC
  list(tran)
}
```

Steady state solution from `rootSolve`.
```{r}
ylocs <- (1:cells) / cells * simlenth
initCondition <- cospi(ylocs) + 1
steadyHeat <- rootSolve::steady.1D(
  y = initCondition,
  func = functionHeat,
  parms = NULL, nspec = 1 #nspec = Number of species
  )
plot(ylocs, steadyHeat$y)
```

What about when we insulate the ends, using the default zero-gradients?

```{r}
functionHeatInsulated <- function(time, Concentration, parameters, 
                         Area = 1, Diffusion = 1, GridThickness = Grid) {
  tran <- ReacTran::tran.1D(
    C = Concentration, A = Area, D = Diffusion, dx = GridThickness
  )$dC
  list(tran)
}
```

```{r}
steadyHeatInsulated <- rootSolve::steady.1D(
  y = initCondition,
  func = functionHeatInsulated,
  parms = NULL, nspec = 1 #nspec = Number of species
  )
plot(ylocs, steadyHeatInsulated$y)
```

Now look at the DE forward solved equivalents.

First, the keep each end fixed at value 0.

```{r}
ts <- (1:cells) / cells
deHeat <- deSolve::ode.1D(
  y = initCondition, 
  times = ts,
  func = functionHeat,
  parms = NULL,
  nspec = 1
)
image(deHeat, grid = Grid$x.mid, xlab = "time", ylab = "distance", add.contour = TRUE)
```

Now insulate both ends so the heat cannot escape.

```{r}
deHeatInsulated <- deSolve::ode.1D(
  y = initCondition, 
  times = ts,
  func = functionHeatInsulated,
  parms = NULL,
  nspec = 1
)
image(deHeatInsulated, grid = Grid$x.mid, xlab = "time", ylab = "distance", add.contour = TRUE)
```
So it seems (again!) that there is something about the way I am using the 
`rootSolve` package that does not seem to match up with expectations.
On the other hand, the `deSolve` package does seem to match better.

For reference, also showing in-flow and out-flow.

```{r}
functionHeatWarming <- function(time, Concentration, parameters, 
                         Area = 1, Diffusion = 1, GridThickness = Grid) {
  tran <- ReacTran::tran.1D(
    C = Concentration, A = Area, D = Diffusion,
    flux.up = 1, flux.down = 0.5, dx = GridThickness
  )$dC
  list(tran)
}
```

```{r}
deHeatWarming <- deSolve::ode.1D(
  y = rep(1, cells), 
  times = ts,
  func = functionHeatWarming,
  parms = NULL,
  nspec = 1
)
image(deHeatWarming, grid = Grid$x.mid, xlab = "time", ylab = "distance", add.contour = TRUE)
```

# Population Diffusion

Now consider a single basal species spreading on our 1-d pipe.

```{r}
poolbasal <- RMTRCode2::LawMorton1996_species(
  Basal = 1, Consumer = 1, 
  Parameters = c(0.01, 10, 0.5, 0.2, 100, 0.1)
)
matbasal <- RMTRCode2::LawMorton1996_CommunityMat(
  Pool = poolbasal, 
  Parameters = c(0.01, 10, 0.5, 0.2, 100, 0.1)
)
```

```{r}
functionBasalInsulated <- function(time, Concentration, parameters, 
                         Area = 1, Diffusion = 1, GridThickness = Grid) {
  # Diffusion-Reaction Component
  tran <- ReacTran::tran.1D(
    C = Concentration, A = Area, D = Diffusion, dx = GridThickness
  )$dC
  
  # Community Dynamics Component
  comm <- with(
    parameters, 
    Concentration * (ReproductionRate + Concentration * Intracompetition)
  )
  
  list(tran + comm)
}
```

```{r}
deBasalInsulated <- deSolve::ode.1D(
  y = rep(1, cells), 
  times = seq(1, 100, by = 1),
  func = functionBasalInsulated,
  parms = list(
    ReproductionRate = poolbasal$ReproductionRate[1],
    Intracompetition = matbasal[1, 1]
  ),
  nspec = 1
)
image(deBasalInsulated, grid = Grid$x.mid, xlab = "time", ylab = "distance", add.contour = TRUE)
```

Note we expect `r -poolbasal$ReproductionRate[1] / matbasal[1, 1]` abundance.

```{r}
deBasalInsulated2 <- deSolve::ode.1D(
  y = c(2000, rep(0, cells - 1)), 
  times = seq(0, 100, by = 0.1),
  func = functionBasalInsulated,
  parms = list(
    ReproductionRate = poolbasal$ReproductionRate[1],
    Intracompetition = matbasal[1, 1]
  ),
  D = 0.001,
  nspec = 1
)
image(deBasalInsulated2, grid = Grid$x.mid, xlab = "time", ylab = "distance", add.contour = TRUE)
```
Note that the diffusion happens very quickly, so we need to use a low diffusivity constant.

# Interacting Population Diffusions Small

Now we want to consider the case of multiple species living together.
We quickly assemble a system to test on.

```{r}
exampleAssemblySmall <- RMTRCode2::LawMorton1996_NumericalAssembly(
  Basal = 1, Consumer = 10, ArrivalEvents = 2500
)
temp <- RMTRCode2::LawMorton1996_PlotAbundance(exampleAssemblySmall$Abundance, guides = FALSE)
temp
```

Check to make sure we have an uninvadable community.
```{r}
nrow(exampleAssemblySmall$Sequence) > which.max(is.na(exampleAssemblySmall$Sequence$Outcome[-1]))
```

Grab the community and its reduced matrix and pool.
```{r}
redComSNum <- which.max(is.na(exampleAssemblySmall$Sequence$Outcome[-1])) - 1
redComS <- exampleAssemblySmall$Sequence$Community[[redComSNum]]
redPoolS <- exampleAssemblySmall$Pool[redComS, ]
redMatS <- exampleAssemblySmall$Matrix[redComS, redComS]
```

Create the function.
```{r}
functionCommunityS <- function(time, Concentration, parameters, 
                         Area = 1, Diffusion = 1, GridThickness = Grid,
                         Pool = redPoolS, Mat = redMatS, Verbose = FALSE) {
  if(Verbose) print(Concentration)
  
  # Looking at deSolve documentation, it looks like we should break up
  # Concentration, e.g.:
  # PREY <- state[1:N]
  # PRED <- state[(N+1):(2*N)]
  # So in general, columns are per species pipes,
  # while the rows are the same point on a pipe but for each species.
  pipeMatrix <- matrix(data = Concentration, ncol = nrow(Pool))
  # Note that matrix automatically fills downward!
  
  if(Verbose) print(pipeMatrix)
  
  # bySpeciesC <- lapply(1:nrow(Pool), function(i, C, nrowP) {
  #   C[((i - 1) * nrowP + 1) : (i * nrowP)]
  # }, C = Concentration, nrowP = nrow(Pool))
  
  # Diffusion-Reaction Component
  # bySpeciesTran <- lapply(bySpeciesC, function(C, A, D, G) {
  #   ReacTran::tran.1D(
  #     C = C, A = A, D = D, dx = G
  #   )$dC
  # }, A = Area, D = Diffusion, G = GridThickness)
  
  pipeMatrixTran <- apply(pipeMatrix, MARGIN = 2, FUN = function(C, A, D, G) {
    ReacTran::tran.1D(
      C = C, A = A, D = D, dx = G
    )$dC
  }, A = Area, D = Diffusion, G = GridThickness)
  
  if(Verbose) print(pipeMatrixTran)
  
  # Community Dynamics Component
  # bySpeciesComm <- lapply(bySpeciesC, function(C, P, M) {
  #   
  # }, P = Pool, M = Mat)
  
  pipeMatrixComm <- t(apply(pipeMatrix, MARGIN = 1, FUN = function(C, t, P, M) {
    unlist(GeneralisedLotkaVolterra(t = t, y = C, 
                             parms = list(
                               a = M,
                               r = P$ReproductionRate
                             )))
  }, t = time, P = Pool, M = Mat))
  
  if(Verbose) print(pipeMatrixComm)
  
  # comm <- 
  #   Concentration * (ReproductionRate + Concentration * Intracompetition)
  
  
  list(pipeMatrixTran + pipeMatrixComm)
}
```

Now we try running it
```{r}
deAssemblySmall <- deSolve::ode.1D(
  y = matrix(
    c(
      exampleAssemblySmall$Abundance[nrow(exampleAssemblySmall$Abundance), -1][redComS],
      rep(0, (cells - 1)* length(redComS))
    ),
    ncol = length(redComS), byrow = TRUE
    ), 
  times = seq(0, 200, by = 0.1),
  func = functionCommunityS,
  parms = NULL,
  D = 0.001,
  nspec = 2
)
```

```{r}
image(deAssemblySmall, grid = Grid$x.mid, xlab = "time", ylab = "distance", add.contour = TRUE)
```

# Interacting Population Diffusions

Now we want to consider the case of multiple species living together.
We quickly assemble a system to test on.

```{r}
exampleAssembly <- RMTRCode2::LawMorton1996_NumericalAssembly(
  Basal = 50, Consumer = 50, ArrivalEvents = 2500
)
temp <- RMTRCode2::LawMorton1996_PlotAbundance(exampleAssembly$Abundance, guides = FALSE)
temp
```

Check to make sure we have an uninvadable community.
```{r}
nrow(exampleAssembly$Sequence) > which.max(is.na(exampleAssembly$Sequence$Outcome[-1]))
```

Grab the community and its reduced matrix and pool.
```{r}
redComNum <- which.max(is.na(exampleAssembly$Sequence$Outcome[-1])) - 1
redCom <- exampleAssembly$Sequence$Community[[redComNum]]
redPool <- exampleAssembly$Pool[redCom, ]
redMat <- exampleAssembly$Matrix[redCom, redCom]
```

Create the function.
```{r}
functionCommunity <- function(time, Concentration, parameters, 
                         Area = 1, Diffusion = 1, GridThickness = Grid,
                         Pool = redPool, Mat = redMat, Verbose = FALSE,
                         ExtinctionThreshold = 0, Circular = FALSE) {
  if(Verbose) print(Concentration)
  
  Concentration[Concentration < ExtinctionThreshold] <- 0
  
  # Looking at deSolve documentation, it looks like we should break up
  # Concentration, e.g.:
  # PREY <- state[1:N]
  # PRED <- state[(N+1):(2*N)]
  # So in general, columns are per species pipes,
  # while the rows are the same point on a pipe but for each species.
  pipeMatrix <- matrix(data = Concentration, ncol = nrow(Pool))
  # Note that matrix automatically fills downward!
  
  # Idea with circular: attach duplicates of first, last evaluation points.
  # Then evaluate as normal. Before finishing, remove the duplicate entries.
  if(Circular) pipeMatrix <- rbind(pipeMatrix[nrow(pipeMatrix), ],
                                   pipeMatrix,
                                   pipeMatrix[1, ])
  
  if(Verbose) print(pipeMatrix)
  
  pipeMatrixTran <- apply(pipeMatrix, MARGIN = 2, FUN = function(C, A, D, G) {
    ReacTran::tran.1D(
      C = C, A = A, D = D, dx = G
    )$dC
  }, A = Area, D = Diffusion, G = GridThickness)
  
  if(Verbose) print(pipeMatrixTran)
  
  pipeMatrixComm <- t(apply(pipeMatrix, MARGIN = 1, FUN = function(C, t, P, M) {
    unlist(GeneralisedLotkaVolterra(t = t, y = C, 
                             parms = list(
                               a = M,
                               r = P$ReproductionRate
                             )))
  }, t = time, P = Pool, M = Mat))
  
  if(Verbose) print(pipeMatrixComm)
  
  if(Circular) pipeMatrixTran <- pipeMatrixTran[c(-1, -nrow(pipeMatrixTran))] 
  if(Circular) pipeMatrixComm <- pipeMatrixComm[c(-1, -nrow(pipeMatrixComm))] 
  
  list(pipeMatrixTran + pipeMatrixComm)
}
```

Now we try running it
```{r}
deAssembly <- deSolve::ode.1D(
  y = matrix(
    c(
      exampleAssembly$Abundance[nrow(exampleAssembly$Abundance), -1][redCom],
      rep(0, (cells - 1)* length(redCom))
    ),
    ncol = length(redCom), byrow = TRUE
    ), 
  times = seq(0, 300, by = 0.1),
  func = functionCommunity,
  parms = NULL,
  D = 0.001,
  nspec = length(redCom),
  Verbose = FALSE
)
```

```{r}
image(deAssembly, grid = Grid$x.mid, xlab = "time", ylab = "distance", add.contour = TRUE)
```

And with an extinction threshold? 
We have to increase dispersal (or extinct less often) to get going!
Furthermore, the extinction threshold modifies run time more than anything 
(since the system becomes more numerically unstable and thus requires more work
by the integrator to resolve nicely).
If the extinction threshold is high, nothing happens, but if the threshold is
slightly lower so that the system can progress, it progresses as normal.
```{r}
deAssemblyExt <- deSolve::ode.1D(
  y = matrix(
    c(
      exampleAssembly$Abundance[nrow(exampleAssembly$Abundance), -1][redCom],
      rep(0, (cells - 1)* length(redCom))
    ),
    ncol = length(redCom), byrow = TRUE
    ), 
  times = seq(0, 300, by = 0.1),
  func = functionCommunity,
  parms = NULL,
  D = 0.001,
  nspec = length(redCom),
  Verbose = FALSE,
  ExtinctionThreshold = 1E-4 # 1E-4 is Extremely Long, 1E-6 is quite short.
)
```

```{r}
image(deAssemblyExt, grid = Grid$x.mid, xlab = "time", ylab = "distance", add.contour = TRUE)
```
