---
title: "Law and Morton 1996: For comparison using numerics"
author: "Brennen Fagan"
date: "Created 2021-03-09, last compiled `r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Law and Morton 1996: For comparison using numerics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r, include = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
```

```{r setup}
library(RMTRCode2)
library(foreach)
parallelise <- tryCatch(
  {
    library(parallel)
    library(doParallel)
    TRUE
  },
  error = function(e) {
    return(FALSE)
  }
)
if (parallelise) {
  cores <- min(c(parallel::detectCores() - 1, 1))
  clust <- parallel::makeCluster(cores)
  doParallel::registerDoParallel(clust)
} else {
  foreach::registerDoSEQ()
}
library(ggplot2)
library(dplyr)
```

# Table 1 and Figure 2
First we create the system suggested by Table 1.

```{r table1pool}
table1Pool <- data.frame(
  ID = 1:4,
  Type = NA,
  Size = NA,
  ReproductionRate = c(0.86, 1.35, -1.01, -0.89)
)

table1Mat <- matrix(
  c(
    -0.97, -0.77, -0.35,  0.00,
    -0.97, -1.08, -0.02,  0.00,
     1.73,  0.29,  0.00, -0.07,
     0.00,  0.00,  1.26,  0.00
  ),
  byrow = TRUE, ncol = 4, nrow = 4
)

table1Record <- matrix(0, nrow = (10 + 1) * 4, ncol = (4 + 1))
table1RecordRow <- 1
table1RecordTime <- 0
```

Next, we introduce species 1 to a system and let it equilibrate.

```{r table1Invade1}
table1Abundance <- c(0.1,0,0,0)
table1Present <- which(table1Abundance > 0)
table1Result <- LawMorton1996_NumIntegration(
      table1Mat[table1Present, table1Present],
      table1Pool$ReproductionRate[table1Present],
      table1Abundance[table1Present],
      OuterTimeStepSize = 20,
      InnerTimeStepSize = 2
    )

table1Abundance_New <- table1Result[nrow(table1Result), 2:ncol(table1Result)]

table1Abundance_New <- ifelse(
      table1Abundance_New > 1E-4 * table1Abundance[table1Present] &
        table1Abundance_New > 0,
      table1Abundance_New,
      0
    )

table1Abundance[table1Present] <- table1Abundance_New
stopifnot((table1Abundance > 0.1) == c(1, 0, 0, 0))

table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 1] <- table1Result[, 1] + table1RecordTime
table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 2] <- table1Result[, 2]
table1RecordRow <- table1RecordRow + nrow(table1Result)
table1RecordTime <- table1RecordTime + table1Result[nrow(table1Result), 1]

table1Result
```

Then we introduce species 4, which should arrive but fail to invade.
Note the system is not uninvadable: checking yields
`r LawMorton1996_CheckUninvadable(c(0, table1Abundance), table1Pool, table1Mat)`.

```{r table1Invade4}
table1Abundance[4] <- table1Abundance[4] + 0.1
table1Present <- which(table1Abundance > 0)
table1Result <- LawMorton1996_NumIntegration(
      table1Mat[table1Present, table1Present],
      table1Pool$ReproductionRate[table1Present],
      table1Abundance[table1Present],
      OuterTimeStepSize = 20,
      InnerTimeStepSize = 2
    )

table1Abundance_New <- table1Result[nrow(table1Result), 2:ncol(table1Result)]

table1Abundance_New <- ifelse(
      table1Abundance_New > 1E-4 * table1Abundance[table1Present] &
        table1Abundance_New > 0,
      table1Abundance_New,
      0
    )

table1Abundance[table1Present] <- table1Abundance_New
stopifnot((table1Abundance > 0.1) == c(1, 0, 0, 0))

table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 1] <- table1Result[, 1] + table1RecordTime
table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 2] <- table1Result[, 2]
table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 5] <- table1Result[, 3]
table1RecordRow <- table1RecordRow + nrow(table1Result)
table1RecordTime <- table1RecordTime + table1Result[nrow(table1Result), 1]

table1Result
```

Species 3, on the other hand, should successfully invade when it arrives and subsequently coexist with species 1.

```{r table1Invade3}
table1Abundance[3] <- table1Abundance[3] + 0.1
table1Present <- which(table1Abundance > 0)
table1Result <- LawMorton1996_NumIntegration(
      table1Mat[table1Present, table1Present],
      table1Pool$ReproductionRate[table1Present],
      table1Abundance[table1Present],
      OuterTimeStepSize = 20,
      InnerTimeStepSize = 2
    )

table1Abundance_New <- table1Result[nrow(table1Result), 2:ncol(table1Result)]

table1Abundance_New <- ifelse(
      table1Abundance_New > 1E-4 * table1Abundance[table1Present] &
        table1Abundance_New > 0,
      table1Abundance_New,
      0
    )

table1Abundance[table1Present] <- table1Abundance_New
stopifnot((table1Abundance > 0.1) == c(1, 0, 1, 0))

table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 1] <- table1Result[, 1] + table1RecordTime
table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 2] <- table1Result[, 2]
table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 4] <- table1Result[, 3]
table1RecordRow <- table1RecordRow + nrow(table1Result)
table1RecordTime <- table1RecordTime + table1Result[nrow(table1Result), 1]

table1Result
```

Note the system is not uninvadable: checking yields
`r LawMorton1996_CheckUninvadable(c(0, table1Abundance), table1Pool, table1Mat)`.

When species 2 invades the community, we instead should see both species 1 and 3 die out.

```{r table1Invade2}
table1Abundance[2] <- table1Abundance[2] + 0.1
table1Present <- which(table1Abundance > 0)
table1Result <- LawMorton1996_NumIntegration(
      table1Mat[table1Present, table1Present],
      table1Pool$ReproductionRate[table1Present],
      table1Abundance[table1Present],
      OuterTimeStepSize = 100,
      InnerTimeStepSize = 2
    )

table1Abundance_New <- table1Result[nrow(table1Result), 2:ncol(table1Result)]

table1Abundance_New <- ifelse(
      table1Abundance_New > 1E-4 * table1Abundance[table1Present] &
        table1Abundance_New > 0,
      table1Abundance_New,
      0
    )

table1Abundance[table1Present] <- table1Abundance_New
stopifnot((table1Abundance > 0.1) == c(0, 1, 0, 0))

table1Result <- table1Result[1:11, ]

table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 1] <- table1Result[, 1] + table1RecordTime
table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 2] <- table1Result[, 2]
table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 3] <- table1Result[, 3]
table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 4] <- table1Result[, 4]
table1RecordRow <- table1RecordRow + nrow(table1Result)
table1RecordTime <- table1RecordTime + table1Result[nrow(table1Result), 1]

table1Result
```

Finally, the system is uninvadable:
`r LawMorton1996_CheckUninvadable(c(0, table1Abundance), table1Pool, table1Mat)`.
This is straightforward to check manually by looking at the per capita growth rates.
```{r table1manualcheck}
table1ManualCheck <- table1Pool$ReproductionRate + table1Mat %*% table1Abundance
stopifnot(round(table1ManualCheck, 2) == c(-0.10, 0, -0.65, -0.89))
table1ManualCheck
```

We can also plot the results.

```{r figure2}
figure2 <- LawMorton1996_PlotAbundance(
  Abundance = table1Record,
  guides = TRUE
)
figure2
```

# Table 2
>Table 2: A community assembly sequence from a pool of 5 basal and 10 consumer species.
The species pool was constructed according to the method given in the Appendix with log body sizes taken at random
from uniform distributions [-2, -1] for basal species and [-1, 0] for consumers. Parameters for generating Lotka-Volterra
terms were: $k_1 = 0.01$, $k_2 = 10$, $k_3 = 0.5$, $k_4 = 0.2$, $k_5 = 100$, and $k_6 = 0.1$. A new species from the pool was chosen at
random at each iteration. Only iterations in which the new species increased when rare are shown. Terms in the columns
labelled $f_i$ give the sign of the per capital rates of increase of species $i$ at the equilibrium point of the resident community.

We will not reproduce this exactly per say, but we can make something close.
Instead of running the entire system using `LawMorton1996`, we will perform each function and save the intermediate results.

```{r parameters}
# > runif(1) * 1E8
# [1] 16528055
set.seed(16528055)
seedsPrep <- runif(2) * 1E8
seedsRun <- runif(1) * 1E8

basal = 5
consumers = 10
logBodySize = c(-2, -1, -1, 0)
parameters = c(0.01, 10, 0.5, 0.2, 100, 0.1)
```

First, we create the pool.
Each species needs an ID, its type, its size, and its reproduction rate specified.

```{r pool}
pool <- LawMorton1996_species(
  Basal = basal, 
  Consumer = consumers, 
  Parameters = parameters, 
  LogBodySize = logBodySize,
  seed = seedsPrep[1]
)
pool
```

Next, we construct our interaction matrix.

```{r interactions}
communityMat <- LawMorton1996_CommunityMat(
  Pool = pool, 
  Parameters = parameters,
  seed = seedsPrep[2]
)
```

This will be of size `basal + consumers` by `basal + consumers` and has the direct effect of each species on each other species, which we will use in a generalised Lotka-Volterra model (eq. 1, Law and Morton, 1996).

Now we will call the central function, providing the prespecified pool and community matrix and running numerical integration to observe how the population changes.
(In effect, we are producing Figure 2 of Law and Morton, 1996.)

```{r initialRun}
results <- LawMorton1996_NumericalAssembly(
  Pool = pool, 
  CommunityMat = communityMat,
  IntegratorTimeStep = 100,
  InnerTimeStepSize = 10,
  ArrivalEvents = 25,
  seed = seedsRun
)
```

The `results` are time ordered abundance data. We now visualise it.

```{r samplePlot}
resultsPlot <- LawMorton1996_PlotAbundance(
  Abundance = results$Abundance,
  Sequence = results$Sequence,
  guides = TRUE
)

speciesPresent <- SpeciesPresent(results$Abundance, Threshold = 2)

resultsPlot
```
We can also construct the progression of assemblages. 
To make sure that it is only species that ``substantially participate'', we set a threshold of $2$, recalling that the initial density on introduction is $1$.
This table is similar to Table 2 in Law and Morton's work (1996), but we do not provide the $f_i$.
Instead, we merely record when species enter and leave the system above a threshold which we set above the arrival density (to prevent false positives).
Notice that, despite continuing to add species in the simulation after time 
`r speciesPresent$TimeStart[nrow(speciesPresent)]`, the populations remain largely the same.

```{r whichNotNA}
dplyr::mutate(speciesPresent, Present = as.character(Present))
```

# Table 3

> Permanent endpoints of some independently randomized species pools.
The pools were constructed as in Table 2, except that the numbers of basal and consumer species were varied as shown
above. Species numbering starts with basal species. One hundred assembly sequences were taken from each pool, with 500
iterations in each. The number of assembly sequences reaching a permanent state by iteration 500 is given in brackets.

First, we check if state 14 in our equivalent of Table 2 is uninvadable.
We use the same threshold as before.

```{r prevUninvadable}
LawMorton1996_CheckUninvadable(
  AbundanceRow = results$Abundance[nrow(results$Abundance),],
  Pool = pool,
  CommunityMatrix = communityMat,
  Threshold = 2
)
```

As one would expect.
(The definition used for uninvadable, for reference is below.

> It it is uninvadable by any other species from the pool because the per
capita rate of increase of each species absent from the community is
negative at the equilibrium point.

The per capita rate of increase is the function $f_i = r_i + \sum_j(a_{ij} x_j)$,
where $r_i$ is the reproduction rate, 
$a_{ij}$ are the interactions, 
and $x_j$ are the abundances.)

So we set the 
number of basal species, 
number of consumer species, 
number of events per run, 
and number of runs.

```{r parameters2}
# > runif(1) * 1E8
# [1] 3680180
set.seed(3680180)

basal2 <- c(5, 10, 15)
consumer2 <- c(20, 40, 60)
events <- 500
runs <- 100

seedsPrep2 <- runif(2 * length(basal2) * length(consumer2)) * 1E8
seedsRun2 <- runif(runs * length(basal2) * length(consumer2)) * 1E8
```

We next produce the nine pools and matrices.

```{r pools2}
pools2 <- foreach::foreach(
  i = 1 : (length(basal2) * length(consumer2)),
  b = rep(basal2, times = length(consumer2)),
  c = rep(consumer2, each = length(basal2)),
  s = seedsPrep2[1:(length(basal2) * length(consumer2))],
  .packages = c("RMTRCode2")
) %dopar% {
  LawMorton1996_species(
    Basal = b, 
    Consumer = c, 
    Parameters = parameters, 
    LogBodySize = logBodySize,
    seed = s
  )
}
```
```{r commats2}
communityMats2 <- foreach::foreach(
  i = seq_along(pools2),
  s = seedsPrep2[
    (length(basal2) * length(consumer2) + 1):(
      2 * length(basal2) * length(consumer2))
  ],
  Pool = pools2,
  .packages = c("RMTRCode2"), .export = c(".Random.seed")
) %dopar% {
  LawMorton1996_CommunityMat(
    Pool = Pool, 
    Parameters = parameters,
    seed = s
  )
}
```

With each pool and community matrix set, we can now perform our runs.
We only preserve the final state of systems that are uninvadable.
The code is straightforward: 
for each combination of numbers of basal and consumer species,
run the system `runs` times, taking the associated pool and community matrix,
check if the result is uninvadable and, if so, store the result.

```{r table3runsv2} 
results2 <- foreach::foreach(
  i = 1 : (length(basal2) * length(consumer2))
) %:% foreach::foreach(
  seed = iterators::iter(seedsRun2[((i - 1) * runs + 1) : (i * runs)])
) %dopar% {
  ourPool <- pools2[[i]]
  ourMat <- communityMats2[[i]]
  
  aRun <- LawMorton1996_NumericalAssembly(
    Pool = ourPool, 
    CommunityMat = ourMat,
    IntegratorTimeStep = 10000, # Empirically closer to permanence method.
    InnerTimeStepSize = NULL, # Only see the results of numerics.
    ArrivalEvents = events,
    ReturnValues = "Abundance", # Now returns only current abundance.
    seed = seed,
    EliminationThreshold = 1E-1
  )
  
  # The function breaks early if the internal system appears to be at
  # steady-state and uninvadable to any new species.
  # Re-run the check to see if the system is still uninvadable.
  if (LawMorton1996_CheckUninvadable(
    AbundanceRow = aRun$Abundance,
    Pool = ourPool,
    CommunityMatrix = ourMat
  )) {
    # and, if so, store the result.
    return(toString(which(!is.na(aRun$Abundance) & aRun$Abundance > 2)[-1] - 1))
  } else {
    return(toString(NULL))
  }
}
```

Once we have the runs, we need to tabulate them.

```{r tabulationRuns}
endPoints <- lapply(results2, function(run) {
  table(unlist(run))
})
endPoints
```

# Table 7

Table 7 is described thusly in the original paper.

>Effect of increasing the number of consumers in
 a species pool on the invasion resistance of communities
 assembled from the pool.
 The initial species pool of five basal species and five
 consumers was constructed by the method described in Table
 2. The species pool was incremented by adding five new
 consumers at a time up to a maximum of 35; these new species
 were chosen at random from the same distributions as the
 first five consumers. Two hundred assembly sequences were
 taken from each pool, with 500 iterations in each. Every
 assembly sequence converged to an endpoint within 500 it-
 erations; for each species pool only one endpoint was ob-
 served. Invasion resistance at each iteration was measured by
 the proportion of assembly sequences in which the new spe-
 cies added at that iteration could not increase, i.e., did not
 satisfy Inequality 3. Sequences that had already reached an
 endpoint were excluded, so the measure of invasion resistance
 corresponds to the line Type 1(b) in Fig. 3B. The proportions
 are given as averages over the period in which between 0.2
 and 0.8 of the assembly sequences were at the endpoint.
 
We begin by constructing a pool with 5 basal and 45 consumer species for a
round 50 species.


```{r table7params}
# > runif(1) * 1E8
# [1] 16528055
set.seed(16528055)

basal7 <- 5
consumers7 <- 45

events7 <- 500
runs7 <- 200

seedsPrep7 <- runif(2) * 1E8
seedsRun7 <- runif(runs7 * (basal7 + consumers7 - 5) / 5) * 1E8
```

```{r pool7}
pool7 <- LawMorton1996_species(
  Basal = basal7, 
  Consumer = consumers7, 
  Parameters = parameters, 
  LogBodySize = logBodySize,
  seed = seedsPrep7[1]
)
pool7
```

```{r interactions7}
communityMat7 <- LawMorton1996_CommunityMat(
  Pool = pool7, 
  Parameters = parameters,
  seed = seedsPrep7[2]
)
```

```{r table7runsv2} 
# p1 <- proc.time()
results7 <- foreach::foreach(
  i = 1:((basal7 + consumers7 - 5) / 5), 
  poollimit = seq(from = 10, by = 5, to = 50)
) %:% foreach::foreach(
  seed = iterators::iter(seedsRun7[((i - 1) * runs7 + 1) : (i * runs7)])
) %do% {
    ourPool <- pool7[1:(poollimit),]
    ourMat <- communityMat7[1:(poollimit), 1:(poollimit)]
  
    aRun <- LawMorton1996_NumericalAssembly(
      Pool = ourPool, 
      CommunityMat = ourMat,
      IntegratorTimeStep = 10000,
      InnerTimeStepSize = 5000, 
      ArrivalEvents = events,
      ReturnValues = c("Abundance", "Sequence"), 
      seed = seed
    )
    
    lastRow <- which(is.na(aRun$Sequence$Community[-1]))[1]
    if (is.na(lastRow)) {
      lastRow <- nrow(aRun$Sequence)
    }
    aRun$Sequence <- aRun$Sequence[1:lastRow, ]
    
    if (LawMorton1996_CheckUninvadable(
      AbundanceRow = aRun$Abundance[nrow(aRun$Abundance), ],
      Pool = ourPool,
      CommunityMatrix = ourMat
    )) {
      # and, if so, store the result.
      return(aRun$Sequence)
    } else {
      return(toString(NULL))
    }
}
# proc.time() - p1
```
```{r recreateTable7}
table7Setup <- lapply(
  seq_along(results7), function(i, r, c) {
    do.call(
      rbind, 
      lapply(r[[i]], function(x) {
        if (!is.atomic(x)) {
          data.frame(
            Iterations = nrow(x), 
            Endpoint = toString(x$Community[[nrow(x)]]), 
            Type1 = sum(x$Outcome == "Type 1 (Failure)", na.rm = TRUE)
          )
        }
      })) %>% dplyr::group_by(Endpoint) %>% dplyr::summarise(
        MeanIterations = mean(Iterations, na.rm = TRUE),
        Successful = n()
      ) %>% dplyr::mutate(
        Basal = 5,
        Consumers = c /length(r) * i
      )
  },
  r = results7, c = consumers7
)

# Need to calculate the mean of the invasion resistance 
table7InvasionResistance <- lapply(
  seq_along(results7), function(i, r, s, c) {
    # group by endpoint
    endpoints <- s[[i]]$Endpoint
    retval <- data.frame(
      Basal = 5, 
      Consumers = c /length(r) * i,
      Endpoint = endpoints, 
      InvasionResistance = NA)
    epcount <- 1
    # for each endpoint,
    for (ep in endpoints) {
      print(ep)
      # keep a list of active assemblies
      active <- unlist(lapply(
        r[[i]], function(x, ep) {
          !is.atomic(x) && toString(x$Community[[nrow(x)]]) == ep
        }, 
        ep = ep
      ))
      #print(active)
      initActive <- active
      initActiveNum <- sum(active, na.rm = TRUE)
      maxTimes <- unlist(lapply(r[[i]][active], nrow))
      # Start at a time when 0.8 of total assemblies are still active.
      # Stop at the time when 0.2 of total assemblies are still active. 
      timeSpan <- quantile(maxTimes, c(0.2, 0.8))
      record <- NULL
      for (time in timeSpan[1]:timeSpan[2]) { # First step is NA.
        # Remove assemblies that have reached their endpoint.
        # Set inactive if your maxTime is over == smaller than current time.
        active[initActive] <- active[initActive] & maxTimes > time
        #print(paste0(sum(active), "/", initActiveNum))
        if (!((sum(active, na.rm = TRUE) / initActiveNum >= 0.2) ||
              (sum(active, na.rm = TRUE) / initActiveNum <= 0.8))
        ) {break}
        # for each timestep (iteration), take Outcome == Type 1 / Outcome != Present
        record <- c(record, (do.call(
          rbind,
          lapply(
            r[[i]][active], 
            function(x, time) {
              data.frame(Outcome = x$Outcome[time])
            },
            time = time
          )
        ) %>% dplyr::summarise(
          out = sum(Outcome == "Type 1 (Failure)") / sum(Outcome != "Present") 
        ))$out)
      }
      # Take the mean of the statistic calculated.
      retval$InvasionResistance[epcount] <- mean(record, na.rm = TRUE)
      epcount <- epcount + 1
    }
    return(retval)
  },
  r = results7, s = table7Setup, c = consumers7
)

table7 <- dplyr::full_join(
  do.call(rbind, table7Setup),
  do.call(rbind, table7InvasionResistance),
  by = c("Basal", "Consumers", "Endpoint")
)

table7
```


```{r finished}
if (parallelise) {
  parallel::stopCluster(clust)
}
```
