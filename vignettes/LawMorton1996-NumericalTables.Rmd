---
title: "Law and Morton 1996: For comparison using numerics"
author: "Brennen Fagan"
date: "Created 2021-03-09, last compiled `r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
%\VignetteIndexEntry{my-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r, include = FALSE}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
```

```{r setup}
library(RMTRCode2)
library(foreach)
parallelise <- tryCatch(
  {
    library(parallel)
    library(doParallel)
    TRUE
  },
  error = function(e) {
    return(FALSE)
  }
)
if (parallelise) {
  clust <- parallel::makeCluster(
    min(c(parallel::detectCores(), 1))
  )
  doParallel::registerDoParallel(clust)
} else {
  foreach::registerDoSEQ()
}
library(ggplot2)
```

# Table 1 and Figure 2
First we create the system suggested by Table 1.

```{r table1pool}
table1Pool <- data.frame(
  ID = 1:4,
  Type = NA,
  Size = NA,
  ReproductionRate = c(0.86, 1.35, -1.01, -0.89)
)

table1Mat <- matrix(
  c(
    -0.97, -0.77, -0.35,  0.00,
    -0.97, -1.08, -0.02,  0.00,
     1.73,  0.29,  0.00, -0.07,
     0.00,  0.00,  1.26,  0.00
  ),
  byrow = TRUE, ncol = 4, nrow = 4
)

table1Record <- matrix(0, nrow = (10 + 1) * 4, ncol = (4 + 1))
table1RecordRow <- 1
table1RecordTime <- 0
```

Next, we introduce species 1 to a system and let it equilibrate.

```{r table1Invade1}
table1Abundance <- c(0.1,0,0,0)
table1Present <- which(table1Abundance > 0)
table1Result <- LawMorton1996_NumIntegration(
      table1Mat[table1Present, table1Present],
      table1Pool$ReproductionRate[table1Present],
      table1Abundance[table1Present],
      OuterTimeStepSize = 20,
      InnerTimeStepSize = 2
    )

table1Abundance_New <- table1Result[nrow(table1Result), 2:ncol(table1Result)]

table1Abundance_New <- ifelse(
      table1Abundance_New > 1E-4 * table1Abundance[table1Present] &
        table1Abundance_New > 0,
      table1Abundance_New,
      0
    )

table1Abundance[table1Present] <- table1Abundance_New
stopifnot((table1Abundance > 0.1) == c(1, 0, 0, 0))

table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 1] <- table1Result[, 1] + table1RecordTime
table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 2] <- table1Result[, 2]
table1RecordRow <- table1RecordRow + nrow(table1Result)
table1RecordTime <- table1RecordTime + table1Result[nrow(table1Result), 1]

table1Result
```

Then we introduce species 4, which should arrive but fail to invade.
Note the system is not uninvadable: checking yields
`r LawMorton1996_CheckUninvadable(c(0, table1Abundance), table1Pool, table1Mat)`.

```{r table1Invade1}
table1Abundance[4] <- table1Abundance[4] + 0.1
table1Present <- which(table1Abundance > 0)
table1Result <- LawMorton1996_NumIntegration(
      table1Mat[table1Present, table1Present],
      table1Pool$ReproductionRate[table1Present],
      table1Abundance[table1Present],
      OuterTimeStepSize = 20,
      InnerTimeStepSize = 2
    )

table1Abundance_New <- table1Result[nrow(table1Result), 2:ncol(table1Result)]

table1Abundance_New <- ifelse(
      table1Abundance_New > 1E-4 * table1Abundance[table1Present] &
        table1Abundance_New > 0,
      table1Abundance_New,
      0
    )

table1Abundance[table1Present] <- table1Abundance_New
stopifnot((table1Abundance > 0.1) == c(1, 0, 0, 0))

table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 1] <- table1Result[, 1] + table1RecordTime
table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 2] <- table1Result[, 2]
table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 5] <- table1Result[, 3]
table1RecordRow <- table1RecordRow + nrow(table1Result)
table1RecordTime <- table1RecordTime + table1Result[nrow(table1Result), 1]

table1Result
```

Species 3, on the other hand, should successfully invade when it arrives and subsequently coexist with species 1.

```{r table1Invade1}
table1Abundance[3] <- table1Abundance[3] + 0.1
table1Present <- which(table1Abundance > 0)
table1Result <- LawMorton1996_NumIntegration(
      table1Mat[table1Present, table1Present],
      table1Pool$ReproductionRate[table1Present],
      table1Abundance[table1Present],
      OuterTimeStepSize = 20,
      InnerTimeStepSize = 2
    )

table1Abundance_New <- table1Result[nrow(table1Result), 2:ncol(table1Result)]

table1Abundance_New <- ifelse(
      table1Abundance_New > 1E-4 * table1Abundance[table1Present] &
        table1Abundance_New > 0,
      table1Abundance_New,
      0
    )

table1Abundance[table1Present] <- table1Abundance_New
stopifnot((table1Abundance > 0.1) == c(1, 0, 1, 0))

table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 1] <- table1Result[, 1] + table1RecordTime
table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 2] <- table1Result[, 2]
table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 4] <- table1Result[, 3]
table1RecordRow <- table1RecordRow + nrow(table1Result)
table1RecordTime <- table1RecordTime + table1Result[nrow(table1Result), 1]

table1Result
```

Note the system is not uninvadable: checking yields
`r LawMorton1996_CheckUninvadable(c(0, table1Abundance), table1Pool, table1Mat)`.

When species 2 invades the community, we instead should see both species 1 and 3 die out.

```{r table1Invade1}
table1Abundance[2] <- table1Abundance[2] + 0.1
table1Present <- which(table1Abundance > 0)
table1Result <- LawMorton1996_NumIntegration(
      table1Mat[table1Present, table1Present],
      table1Pool$ReproductionRate[table1Present],
      table1Abundance[table1Present],
      OuterTimeStepSize = 100,
      InnerTimeStepSize = 2
    )

table1Abundance_New <- table1Result[nrow(table1Result), 2:ncol(table1Result)]

table1Abundance_New <- ifelse(
      table1Abundance_New > 1E-4 * table1Abundance[table1Present] &
        table1Abundance_New > 0,
      table1Abundance_New,
      0
    )

table1Abundance[table1Present] <- table1Abundance_New
stopifnot((table1Abundance > 0.1) == c(0, 1, 0, 0))

table1Result <- table1Result[1:11, ]

table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 1] <- table1Result[, 1] + table1RecordTime
table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 2] <- table1Result[, 2]
table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 3] <- table1Result[, 3]
table1Record[table1RecordRow:(nrow(table1Result) + table1RecordRow - 1), 4] <- table1Result[, 4]
table1RecordRow <- table1RecordRow + nrow(table1Result)
table1RecordTime <- table1RecordTime + table1Result[nrow(table1Result), 1]

table1Result
```

Finally, the system is uninvadable:
`r LawMorton1996_CheckUninvadable(c(0, table1Abundance), table1Pool, table1Mat)`.
This is straightforward to check manually by looking at the per capita growth rates.
```{r table1manualcheck}
table1ManualCheck <- table1Pool$ReproductionRate + table1Mat %*% table1Abundance
stopifnot(round(table1ManualCheck, 2) == c(-0.10, 0, -0.65, -0.89))
table1ManualCheck
```

We can also plot the results.

```{r figure2}
figure2 <- LawMorton1996_PlotAbundance(
  Abundance = table1Record,
  guides = TRUE
)
figure2
```

# Table 2
>Table 2: A community assembly sequence from a pool of 5 basal and 10 consumer species.
The species pool was constructed according to the method given in the Appendix with log body sizes taken at random
from uniform distributions [-2, -1] for basal species and [-1, 0] for consumers. Parameters for generating Lotka-Volterra
terms were: $k_1 = 0.01$, $k_2 = 10$, $k_3 = 0.5$, $k_4 = 0.2$, $k_5 = 100$, and $k_6 = 0.1$. A new species from the pool was chosen at
random at each iteration. Only iterations in which the new species increased when rare are shown. Terms in the columns
labelled $f_i$ give the sign of the per capital rates of increase of species $i$ at the equilibrium point of the resident community.

We will not reproduce this exactly per say, but we can make something close.
Instead of running the entire system using `LawMorton1996`, we will perform each function and save the intermediate results.

```{r parameters}
# > runif(1) * 1E8
# [1] 16528055
set.seed(16528055)
seedsPrep <- runif(2) * 1E8
seedsRun <- runif(1) * 1E8

basal = 5
consumers = 10
logBodySize = c(-2, -1, -1, 0)
parameters = c(0.01, 10, 0.5, 0.2, 100, 0.1)
```

First, we create the pool.
Each species needs an ID, its type, its size, and its reproduction rate specified.

```{r pool}
pool <- LawMorton1996_species(
  Basal = basal, 
  Consumer = consumers, 
  Parameters = parameters, 
  LogBodySize = logBodySize,
  seed = seedsPrep[1]
)
pool
```

Next, we construct our interaction matrix.

```{r interactions}
communityMat <- LawMorton1996_CommunityMat(
  Pool = pool, 
  Parameters = parameters,
  seed = seedsPrep[2]
)
```

This will be of size `basal + consumers` by `basal + consumers` and has the direct effect of each species on each other species, which we will use in a generalised Lotka-Volterra model (eq. 1, Law and Morton, 1996).

Now we will call the central function, providing the prespecified pool and community matrix and running numerical integration to observe how the population changes.
(In effect, we are producing Figure 2 of Law and Morton, 1996.)

```{r initialRun}
results <- LawMorton1996_NumericalAssembly(
  Pool = pool, 
  CommunityMat = communityMat,
  IntegratorTimeStep = 100,
  InnerTimeStepSize = 10,
  ArrivalEvents = 25,
  seed = seedsRun
)
```

The `results` are time ordered abundance data. We now visualise it.

```{r samplePlot}
resultsPlot <- LawMorton1996_PlotAbundance(
  Abundance = results$Abundance,
  Sequence = results$Sequence,
  guides = TRUE
)
resultsPlot
```
We can also construct the progression of assemblages. 
To make sure that it is only species that ``substantially participate'', we set a threshold of $2$, recalling that the initial density on introduction is $1$.
This table is similar to Table 2 in Law and Morton's work (1996), but we do not provide the $f_i$.
Instead, we merely record when species enter and leave the system above a threshold which we set above the arrival density (to prevent false positives).
Notice that, despite continuing to add species in the simulation after time 
`r speciesPresent$TimeStart[nrow(speciesPresent)]`, the populations remain largely the same.

```{r whichNotNA}
speciesPresent <- SpeciesPresent(results$Abundance, Threshold = 2)

dplyr::mutate(speciesPresent, Present = as.character(Present))
```

# Table 3

> Permanent endpoints of some independently randomized species pools.
The pools were constructed as in Table 2, except that the numbers of basal and consumer species were varied as shown
above. Species numbering starts with basal species. One hundred assembly sequences were taken from each pool, with 500
iterations in each. The number of assembly sequences reaching a permanent state by iteration 500 is given in brackets.

First, we check if state 14 in our equivalent of Table 2 is uninvadable.
We use the same threshold as before.

```{r prevUninvadable}
LawMorton1996_CheckUninvadable(
  AbundanceRow = results$Abundance[nrow(results$Abundance),],
  Pool = pool,
  CommunityMatrix = communityMat,
  Threshold = 2
)
```

As one would expect.
(The definition used for uninvadable, for reference is below.

> It it is uninvadable by any other species from the pool because the per
capita rate of increase of each species absent from the community is
negative at the equilibrium point.

The per capita rate of increase is the function $f_i = r_i + \sum_j(a_{ij} x_j)$,
where $r_i$ is the reproduction rate, 
$a_{ij}$ are the interactions, 
and $x_j$ are the abundances.)

So we set the 
number of basal species, 
number of consumer species, 
number of events per run, 
and number of runs.

```{r parameters2}
# > runif(1) * 1E8
# [1] 3680180
set.seed(3680180)

basal2 <- c(5, 10, 15)
consumer2 <- c(20, 40, 60)
events <- 500
runs <- 100

seedsPrep2 <- runif(2 * length(basal2) * length(consumer2)) * 1E8
seedsRun2 <- runif(runs * length(basal2) * length(consumer2)) * 1E8
```

We next produce the nine pools and matrices.

```{r pools2}
pools2 <- lapply(
  1 : (length(basal2) * length(consumer2)), 
  function(i, b, c, s, parameters, logBodySize) {
    LawMorton1996_species(
      Basal = b[i], 
      Consumer = c[i], 
      Parameters = parameters, 
      LogBodySize = logBodySize,
      seed = s[i]
    )
  },
  b = rep(basal2, times = length(consumer2)),
  c = rep(consumer2, each = length(basal2)),
  s = seedsPrep2[1:(length(basal2) * length(consumer2))],
  parameters = parameters, logBodySize = logBodySize
)
```
```{r commats2}
communityMats2 <- lapply(
  seq_along(pools2), 
  function(i, pools, parameters, s) {
    LawMorton1996_CommunityMat(
      Pool = pools[[i]], 
      Parameters = parameters,
      seed = s[i]
    )
  }, 
  pools = pools2,
  parameters = parameters,
  s = seedsPrep2[(length(basal2) * length(consumer2) + 1):(
    2 * length(basal2) * length(consumer2))]
)
```

With each pool and community matrix set, we can now perform our runs.
We only preserve the final state of systems that are uninvadable.
The code is straightforward: 
for each combination of numbers of basal and consumer species,
run the system `runs` times, taking the associated pool and community matrix,
check if the result is uninvadable and, if so, store the result.

```{r table3runsv2} 
results2 <- lapply(
  # for each combination of numbers of basal and consumer species
  1 : (length(basal2) * length(consumer2)), 
  function(i, pools, communityMats, events, runs, seeds) {
    ourSeeds <- seeds[((i - 1) * runs + 1) : (i * runs)]
    ourPool <- pools[[i]]
    ourMat <- communityMats[[i]]
    
    # run the system `runs` times
    foreach::foreach(
      seed = iterators::iter(ourSeeds)
    ) %dopar% {
      aRun <- LawMorton1996_NumericalAssembly(
        Pool = ourPool, 
        CommunityMat = ourMat,
        IntegratorTimeStep = 100,
        InnerTimeStepSize = NULL, # Only see the results of numerics.
        ArrivalEvents = events,
        ReturnValues = "Abundance", # Now returns only current abundance.
        seed = seed
      )
      
      if (LawMorton1996_CheckUninvadable(
        AbundanceRow = aRun$Abundance,
        Pool = ourPool,
        CommunityMatrix = ourMat,
        Threshold = 2
      )) {
        # and, if so, store the result.
        return(toString(which(!is.na(aRun$Abundance) & aRun$Abundance > 2)))
      } else {
        return(toString(NULL))
      }
    }
  },
  pools = pools2,
  communityMats = communityMats2,
  events = events, runs = runs, seeds = seedsRun2
)
```

Once we have the runs, we need to tabulate them.

```{r tabulationRuns}
endPoints <- lapply(results2, function(run) {
  table(unlist(run))
})
endPoints
```

# Table 7


```{r finished}
if (parallelise) {
  parallel::stopCluster(clust)
}
```
